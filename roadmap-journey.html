<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>React Roadmap â€“ Scroll Path</title>
  <style>
    :root{
      --bg:#000000;
      --sand:#BCB19B;
      --rust:#672714;
    }
    *{box-sizing:border-box}
    html,body{margin:0;background:var(--bg);color:var(--sand);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #root{width:100%}

    .wrap{
      width: 100%;
      position: relative;
    }
    .header{
      position:sticky; top:0;
      background:linear-gradient(180deg, rgba(0,0,0,0.9), rgba(0,0,0,0.6));
      backdrop-filter: blur(6px);
      border-bottom:1px solid rgba(188,177,155,0.2);
      z-index:50;
    }
    .header-inner{
      max-width:1100px;margin:0 auto;padding:16px 20px;display:flex;gap:12px;align-items:center;justify-content:space-between;
    }
    .brand{font-weight:700;letter-spacing:.5px}
    .legend{font-size:12px;opacity:.85}

    .stage{
      position:relative; max-width:1100px; margin:0 auto; padding:60px 20px 140px;
      min-height:1400px;
    }

    .svg-road{
      width:100%; height:1400px; display:block;
      filter: drop-shadow(0 10px 30px rgba(188,177,155,0.08));
    }

    .road-base{ stroke:var(--sand); stroke-width:18; fill:none; stroke-linecap:round; opacity:.9 }
    .road-flow{ stroke:var(--rust); stroke-width:6; fill:none; stroke-linecap:round }
    .road-centerline{ stroke:var(--bg); stroke-width:2; stroke-dasharray:6 12; opacity:.35 }

    .node{
      position:absolute; transform:translate(-50%, -50%) scale(.85);
      background:rgba(0,0,0,.65);
      border:1px solid rgba(188,177,155,.35);
      color:var(--sand);
      padding:10px 12px; border-radius:14px;
      display:flex; gap:10px; align-items:center;
      opacity:0; filter:blur(6px); transition:opacity .6s ease, filter .6s ease, transform .6s ease;
      pointer-events:none;
    }

    .node-badge{
      width:28px; height:28px; border-radius:50%;
      background:var(--rust); color:#fff; display:grid; place-items:center;
      font-size:13px; font-weight:700; box-shadow:0 2px 10px rgba(103,39,20,.35);
      border:2px solid rgba(255,255,255,.1);
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .node.active{
      opacity:1; filter:blur(0); transform:translate(-50%, -50%) scale(1);
    }

    .node.active .node-badge{
      transform: scale(1.2);
      box-shadow: 0 12px 40px rgba(188, 177, 155, 0.4), 0 0 0 8px rgba(188, 177, 155, 0.1);
      background: linear-gradient(135deg, var(--sand), #fff);
      color: var(--bg);
    }

    .node h4{font-size:14px; margin:0; line-height:1.2}
    .node small{display:block; font-size:11px; opacity:.8; margin-top:2px}

    .toast{
      position:fixed; left:50%; bottom:20px; transform:translateX(-50%);
      background:rgba(188,177,155,.08);
      border:1px solid rgba(188,177,155,.35);
      color:var(--sand);
      padding:14px 18px; border-radius:16px; max-width:90vw;
      display:flex; gap:10px; align-items:flex-start;
      backdrop-filter: blur(6px);
      box-shadow:0 12px 40px rgba(0,0,0,.35);
      z-index:60; opacity:0; transition:opacity .4s ease, transform .4s ease;
    }

    .toast.show{ opacity:1; transform:translateX(-50%) translateY(0) }
    .toast .dot{ width:10px; height:10px; border-radius:50%; background:var(--rust); margin-top:6px }
    .toast strong{ color:var(--sand) }
    .toast p{ margin:0; font-size:13px; line-height:1.5; opacity:.95 }

    .progress{
      height:4px; width:100%; background:rgba(188,177,155,.15); border-radius:999px; overflow:hidden;
    }

    .progress > span{
      display:block; height:100%; width:0%;
      background:var(--rust); transition:width .15s linear;
    }

    .btn{
      border:1px solid rgba(188,177,155,.35);
      color:var(--sand); background:rgba(188,177,155,.06);
      padding:8px 10px; border-radius:10px; font-size:12px; cursor:pointer;
    }

    .btn:hover{ background:rgba(188,177,155,.12) }
  </style>
</head>
<body>
  <div id="root">
    <div class="wrap">
      <header class="header">
        <div class="header-inner">
          <div style="display:flex;align-items:center;gap:12px">
            <span class="brand">Growth Journey</span>
            <div class="legend">AEO/GEO Scroll Roadmap</div>
          </div>
          <div id="nav-buttons" style="display:flex;gap:8px;align-items:center"></div>
        </div>
        <div class="header-inner" style="padding-top:0">
          <div class="progress" aria-hidden="true">
            <span id="progress-bar" style="width: 0%"></span>
          </div>
        </div>
      </header>

      <div class="stage">
        <svg class="svg-road" id="svg-road" viewBox="0 0 1100 1400" preserveAspectRatio="xMidYMin slice" aria-hidden="true">
          <!-- Curvy road path -->
          <path
            id="roadPath"
            class="road-base"
            d="M150,40
               C 380,160  200,260  430,340
               S 700,520  520,620
               S 240,780  480,900
               S 900,1080 720,1200
               S 420,1300 540,1380" />
          <path
            id="roadFlow"
            class="road-flow"
            d="M150,40
               C 380,160  200,260  430,340
               S 700,520  520,620
               S 240,780  480,900
               S 900,1080 720,1200
               S 420,1300 540,1380" />
          <path
            id="roadCenter"
            class="road-centerline"
            d="M150,40
               C 380,160  200,260  430,340
               S 700,520  520,620
               S 240,780  480,900
               S 900,1080 720,1200
               S 420,1300 540,1380" />
        </svg>

        <!-- Nodes will be positioned by JS -->
        <div id="nodes-container"></div>
      </div>

      <div id="toast" class="toast" role="status" aria-live="polite">
        <span class="dot" aria-hidden="true"></span>
        <div>
          <strong id="toast-title"></strong>
          <p id="toast-message"></p>
        </div>
      </div>
    </div>
  </div>

  <script>
    const NODES = [
      {id:1, title:"Site Analysis", msg:"Audit structure, speed, accessibility, indexation, and content depth to spot quick wins."},
      {id:2, title:"Competitor Analysis", msg:"Benchmark SERP presence, content gaps, link velocity, and UX patterns that are winning."},
      {id:3, title:"AEO Audit Report", msg:"Assess on-page answerability, schema coverage, FAQs, and intent satisfaction for AI/answer engines."},
      {id:4, title:"AEO", msg:"Implement entities, schemas, concise answers, and semantic linking to own direct answers."},
      {id:5, title:"GEO", msg:"Localize + geo-intent landing pages, NAP signals, and proximity content to capture local demand."}
    ];

    let nodePositions = [];
    let activeIndex = -1;
    let pathLength = 0;

    function rafThrottle(fn){let ticking=false;return function(...args){if(!ticking){requestAnimationFrame(()=>{fn(...args);ticking=false});ticking=true;}}}

    function initializeNodePositions(){
      const path = document.getElementById('roadPath');
      const flow = document.getElementById('roadFlow');
      if(!path) return;
      const total = path.getTotalLength();
      pathLength = total;
      const offsets=[0.08,0.28,0.49,0.70,0.9].map(p=>p*total);
      nodePositions = offsets.map(len=>path.getPointAtLength(len));

      if(flow){flow.style.strokeDasharray=total+" "+total; flow.style.strokeDashoffset=total;}
      createNodes();
    }

    function createNodes(){
      const container=document.getElementById('nodes-container');
      container.innerHTML='';
      nodePositions.forEach((pt,i)=>{
        const node=document.createElement('div');
        node.className='node';
        node.dataset.index=i;
        node.style.left=pt.x+'px';
        node.style.top=pt.y+'px';
        node.style.maxWidth='260px';
        node.setAttribute('aria-label',`Node ${i+1}: ${NODES[i].title}`);
        node.innerHTML=`<div class="node-badge">${i+1}</div><div><h4>${NODES[i].title}</h4><small>Waypoint ${i+1} of ${NODES.length}</small></div>`;
        container.appendChild(node);
      });
    }

    function createNavButtons(){
      const container=document.getElementById('nav-buttons'); container.innerHTML='';
      NODES.forEach((n,i)=>{
        const button=document.createElement('button');
        button.className='btn';
        button.textContent=`${n.id}. ${n.title.split(' ')[0]}`;
        button.onclick=()=>jumpTo(i);
        container.appendChild(button);
      });
    }

    // Jump to specific node
    function jumpTo(i) {
      const box = document.querySelector(`.node[data-index="${i}"]`);
      if (!box) return;
      
      const rect = box.getBoundingClientRect();
      const offset = window.scrollY + rect.top - (window.innerHeight * 0.35);
      window.scrollTo({ top: offset, behavior: 'smooth' });
    }

    // Handle scroll events
    function handleScroll() {
      const flow = document.getElementById('roadFlow');
      const progressBar = document.getElementById('progress-bar');
      const stage = document.querySelector('.stage');
      
      if (!flow || !stage) return;

      // Calculate progress based on stage position relative to viewport
      const stageRect = stage.getBoundingClientRect();
      const stageTop = stageRect.top;
      const stageHeight = stageRect.height;
      const viewportHeight = window.innerHeight;
      
      // Progress calculation: 0 when stage top is at bottom of viewport, 1 when stage bottom is at top
      const scrollProgress = Math.max(0, Math.min(1, (viewportHeight - stageTop) / (stageHeight + viewportHeight)));
      progress = scrollProgress;

      // Update progress bar
      if (progressBar) {
        progressBar.style.width = `${Math.round(scrollProgress * 100)}%`;
      }

      // Draw the road "flow" progressively
      const drawLen = pathLength * (0.08 + 0.92 * scrollProgress);
      flow.style.strokeDashoffset = Math.max(pathLength - drawLen, 0);

      // Update active nodes
      updateActiveNodes();
    }

    // Update which nodes are active based on scroll position
    function updateActiveNodes() {
      const nodes = document.querySelectorAll('.node');
      let bestIndex = -1;
      let bestScore = -1;

      nodes.forEach((node, i) => {
        const rect = node.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        
        // Check if node is visible in viewport
        const isVisible = rect.top < viewportHeight && rect.bottom > 0;
        
        if (isVisible) {
          // Calculate how centered the node is in the viewport
          const nodeCenter = rect.top + rect.height / 2;
          const viewportCenter = viewportHeight / 2;
          const distanceFromCenter = Math.abs(nodeCenter - viewportCenter);
          const maxDistance = viewportHeight * 0.4;
          
          // Score based on how close to center (higher score = closer to center)
          const centerScore = Math.max(0, 1 - (distanceFromCenter / maxDistance));
          
          // Also consider how much of the node is visible
          const visibleTop = Math.max(rect.top, 0);
          const visibleBottom = Math.min(rect.bottom, viewportHeight);
          const visibleHeight = Math.max(0, visibleBottom - visibleTop);
          const visibilityRatio = visibleHeight / rect.height;
          
          const totalScore = centerScore * visibilityRatio;
          
          if (totalScore > bestScore) {
            bestScore = totalScore;
            bestIndex = i;
          }
        }
      });

      if (bestIndex !== activeIndex) {
        // Remove active class from all nodes
        nodes.forEach(node => node.classList.remove('active'));
        
        // Add active class to nodes up to and including the best index
        for (let i = 0; i <= bestIndex; i++) {
          if (nodes[i]) {
            nodes[i].classList.add('active');
          }
        }

        activeIndex = bestIndex;
        updateToast();
      }
    }

    function updateToast(){
      const toast=document.getElementById('toast');
      const title=document.getElementById('toast-title');
      const message=document.getElementById('toast-message');
      if(activeIndex>=0 && NODES[activeIndex]){
        const item=NODES[activeIndex];
        title.textContent=`${item.id}. ${item.title}`;
        message.textContent=item.msg;
        toast.classList.add('show');
      } else {toast.classList.remove('show');}
    }

    function init(){
      createNavButtons();
      initializeNodePositions();
      
      // Set up scroll listener on window
      const throttledScroll = rafThrottle(handleScroll);
      window.addEventListener('scroll', throttledScroll, { passive: true });
      
      // Initial call
      handleScroll();
    }

    if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',init);} else{init();}
  </script>
</body>
</html>
