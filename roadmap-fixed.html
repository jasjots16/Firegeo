<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Curvy Roadmap Widget</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body { 
      margin: 0; 
      padding: 0; 
      background: #000; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      color: #BCB19B;
    }
    
    #roadmap { 
      min-height: 1000px; 
      position: relative;
      padding: 40px;
    }
    
    .timeline { 
      position: relative; 
      padding-left: 40px; 
    }
    
    svg { 
      position: absolute; 
      left: 0; 
      top: 0; 
      width: 100%; 
      pointer-events: none; 
    }
    
    path { 
      fill: none; 
      stroke-linecap: round; 
    }
    
    .bg { 
      stroke: #BCB19B; 
      opacity: 0.15; 
      stroke-width: 6; 
    }
    
    .progress { 
      stroke: #BCB19B; 
      stroke-width: 6; 
    }
    
    .node { 
      margin: 80px 0; 
      opacity: 0; 
      transform: translateY(36px) scale(0.96);
      transition: all .7s cubic-bezier(.2,.9,.2,1);
    }
    
    .node.visible { 
      opacity: 1; 
      transform: translateY(0) scale(1); 
    }
    
    .dot { 
      position: absolute; 
      left: -10px; 
      width: 36px; 
      height: 36px; 
      border-radius: 50%;
      background: linear-gradient(135deg, #672714, #BCB19B);
      display: flex; 
      align-items: center; 
      justify-content: center; 
      color: #000;
      font-weight: 700; 
      box-shadow: 0 6px 20px rgba(0,0,0,.6);
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 10;
    }
    
    .dot.active {
      transform: scale(1.2);
      box-shadow: 0 12px 40px rgba(188, 177, 155, 0.4), 0 0 0 8px rgba(188, 177, 155, 0.1);
      background: linear-gradient(135deg, #BCB19B, #fff);
    }
    
    .dot.completed {
      background: linear-gradient(135deg, #BCB19B, #fff);
      box-shadow: 0 8px 25px rgba(188, 177, 155, 0.3);
    }
    
    .card { 
      margin-left: 60px; 
      background: rgba(255,255,255,.03); 
      border: 1px solid rgba(255,255,255,.04);
      padding: 18px; 
      border-radius: 12px;
    }
    
    .card h3 {
      margin: 0 0 6px;
      color: #BCB19B;
    }
    
    .card p {
      margin: 0;
      color: #ddd;
    }
    
    .message { 
      position: fixed; 
      right: 24px; 
      bottom: 24px; 
      min-width: 300px; 
      max-width: 480px;
      background: #BCB19B; 
      color: #000; 
      padding: 22px 26px; 
      border-radius: 14px;
      box-shadow: 0 18px 46px rgba(0,0,0,.75); 
      transform: translateY(20px);
      opacity: 0; 
      transition: all .42s ease; 
      font-size: 1.05rem;
    }
    
    .message.show { 
      opacity: 1; 
      transform: translateY(0); 
    }
    
    .message-title {
      font-weight: 700;
      margin-bottom: 8px;
    }
    
    h2 {
      margin: 0;
      fontSize: 28px;
      color: #BCB19B;
    }
    
    .subtitle {
      color: #ccc;
    }
  </style>
</head>
<body>
  <div id="roadmap">
    <h2>Roadmap</h2>
    <p class="subtitle">Scroll to reveal each stage.</p>
    
    <div class="timeline">
      <svg id="svg">
        <path id="bg-path" class="bg" d=""></path>
        <path id="progress-path" class="progress" d=""></path>
      </svg>

      <div class="node" data-index="0">
        <div class="dot">1</div>
        <div class="card">
          <h3>Site Analysis</h3>
          <p>Deep crawl, speed & structure insights</p>
        </div>
      </div>

      <div class="node" data-index="1">
        <div class="dot">2</div>
        <div class="card">
          <h3>Competitor Analysis</h3>
          <p>Compare visibility, gaps & wins</p>
        </div>
      </div>

      <div class="node" data-index="2">
        <div class="dot">3</div>
        <div class="card">
          <h3>AEO Audit Report</h3>
          <p>Actionable AEO changes & score</p>
        </div>
      </div>

      <div class="node" data-index="3">
        <div class="dot">4</div>
        <div class="card">
          <h3>AEO</h3>
          <p>Answer-first optimisation workflows</p>
        </div>
      </div>

      <div class="node" data-index="4">
        <div class="dot">5</div>
        <div class="card">
          <h3>GEO</h3>
          <p>Location intelligence & local reach</p>
        </div>
      </div>
    </div>

    <div id="message" class="message">
      <div class="message-title">Scroll to begin</div>
      <div class="message-content"></div>
    </div>
  </div>

  <script>
    // Data for the nodes
    const nodes = [
      { title: "Site Analysis", message: "Deep crawl, speed & structure insights" },
      { title: "Competitor Analysis", message: "Compare visibility, gaps & wins" },
      { title: "AEO Audit Report", message: "Actionable AEO changes & score" },
      { title: "AEO", message: "Answer-first optimisation workflows" },
      { title: "GEO", message: "Location intelligence & local reach" }
    ];

    let activeIndex = null;
    let pathLength = 0;

    // Generate curved path
    function generatePath(height, width) {
      const x = Math.min(48, Math.max(24, Math.round(width * 0.06)));
      
      // Calculate positions based on actual node positions
      const nodeElements = document.querySelectorAll('.node');
      const ys = [];
      
      if (nodeElements.length > 0) {
        nodeElements.forEach(node => {
          const rect = node.getBoundingClientRect();
          const containerRect = document.getElementById('roadmap').getBoundingClientRect();
          ys.push(rect.top - containerRect.top + rect.height / 2);
        });
      } else {
        // Fallback if nodes aren't rendered yet
        const spacing = 160; // 80px margin * 2
        const startY = 120;
        for (let i = 0; i < 5; i++) {
          ys.push(startY + i * spacing);
        }
      }
      
      const pts = ys.map(y => ({ x, y }));
      let d = `M ${pts[0].x},${pts[0].y}`;
      
      for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i], b = pts[i + 1];
        const distance = Math.abs(b.y - a.y);
        const hor = Math.min(120, Math.max(40, distance * 0.3));
        
        // Smoother curve control points
        const c1x = a.x + (i % 2 === 0 ? hor : -hor * 0.7);
        const c2x = b.x + (i % 2 === 0 ? -hor * 0.7 : hor);
        const c1y = a.y + (b.y - a.y) * 0.25;
        const c2y = a.y + (b.y - a.y) * 0.75;
        
        d += ` C ${c1x},${c1y} ${c2x},${c2y} ${b.x},${b.y}`;
      }
      return d;
    }

    // Update path
    function updatePath() {
      const container = document.getElementById('roadmap');
      const svg = document.getElementById('svg');
      const pathEl = document.getElementById('progress-path');
      const bgPathEl = document.getElementById('bg-path');
      
      if (!container || !svg || !pathEl || !bgPathEl) return;
      
      const w = container.clientWidth;
      const h = container.scrollHeight;
      const d = generatePath(h, w);
      
      pathEl.setAttribute("d", d);
      bgPathEl.setAttribute("d", d);
      svg.setAttribute("viewBox", `0 0 ${Math.max(120, w)} ${h}`);
      svg.style.height = h + "px";
      
      pathLength = pathEl.getTotalLength();
      pathEl.style.strokeDasharray = pathLength;
      pathEl.style.strokeDashoffset = pathLength;
      bgPathEl.style.strokeDasharray = pathLength;
      bgPathEl.style.strokeDashoffset = 0;
    }

    // Handle scroll
    function onScroll() {
      const container = document.getElementById('roadmap');
      const pathEl = document.getElementById('progress-path');
      
      if (!container || !pathEl) return;
      
      const rect = container.getBoundingClientRect();
      const top = window.scrollY + rect.top;
      const h = rect.height;
      const viewportBottom = window.scrollY + window.innerHeight;
      let progress = (viewportBottom - top) / h;
      progress = Math.min(Math.max(progress, 0), 1);
      const min = 0.06;
      const norm = min + progress * (1 - min);
      pathEl.style.strokeDashoffset = pathLength * (1 - norm);
      
      // Update dot states based on line progress
      updateDotStates(norm);
    }
    
    // Update dot states based on line progress
    function updateDotStates(progress) {
      const dots = document.querySelectorAll('.dot');
      const nodeCount = dots.length;
      
      dots.forEach((dot, index) => {
        const nodeProgress = (index + 1) / nodeCount;
        
        // Remove all state classes
        dot.classList.remove('active', 'completed');
        
        if (progress >= nodeProgress) {
          // Line has passed this dot
          dot.classList.add('completed');
        } else if (progress >= nodeProgress - 0.1) {
          // Line is approaching/at this dot
          dot.classList.add('active');
        }
      });
    }

    // Update message
    function updateMessage(index) {
      const messageEl = document.getElementById('message');
      const titleEl = messageEl.querySelector('.message-title');
      const contentEl = messageEl.querySelector('.message-content');
      
      if (index !== null && nodes[index]) {
        titleEl.textContent = nodes[index].title;
        contentEl.textContent = nodes[index].message;
        messageEl.classList.add('show');
      } else {
        titleEl.textContent = 'Scroll to begin';
        contentEl.textContent = '';
        messageEl.classList.remove('show');
      }
    }

    // Initialize
    function init() {
      // Update path
      updatePath();
      
      // Set up intersection observer
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const index = Number(entry.target.dataset.index);
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
            activeIndex = index;
            updateMessage(index);
          } else {
            entry.target.classList.remove('visible');
          }
        });
      }, { threshold: 0.25 });

      // Observe all nodes
      document.querySelectorAll('.node').forEach(node => {
        observer.observe(node);
      });

      // Set up scroll listener
      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', updatePath);
      
      // Initial scroll check
      onScroll();
    }

    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>