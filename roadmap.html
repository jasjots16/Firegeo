<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Curvy Roadmap Widget</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- ✅ Updated React + ReactDOM + Babel from CDNs -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    html, body { 
      margin: 0; 
      padding: 0; 
      background: #000; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    }
    #roadmap { 
      min-height: 2200px; 
    }
  </style>
</head>
<body>
  <div id="roadmap"></div>

  <!-- ✅ React component with Babel -->
  <script type="text/babel">
    const { useEffect, useRef, useState } = React;

    function Roadmap() {
      const containerRef = useRef(null);
      const svgRef = useRef(null);
      const pathRef = useRef(null);
      const bgPathRef = useRef(null);
      const [activeIndex, setActiveIndex] = useState(null);
      const pathLenRef = useRef(0);

      const colors = { bg: "#000000", accent: "#BCB19B", deep: "#672714" };
      const nodes = [
        { title: "Site Analysis", message: "Deep crawl, speed & structure insights" },
        { title: "Competitor Analysis", message: "Compare visibility, gaps & wins" },
        { title: "AEO Audit Report", message: "Actionable AEO changes & score" },
        { title: "AEO", message: "Answer-first optimisation workflows" },
        { title: "GEO", message: "Location intelligence & local reach" }
      ];

      const generatePath = (height, width) => {
        const x = Math.min(48, Math.max(24, Math.round(width * 0.06)));
        const ys = [0.04, 0.22, 0.42, 0.64, 0.92].map(p => Math.round(p * height));
        const pts = ys.map(y => ({ x, y }));
        let d = `M ${pts[0].x},${pts[0].y}`;
        
        for (let i = 0; i < pts.length - 1; i++) {
          const a = pts[i], b = pts[i + 1];
          const hor = Math.min(80, Math.max(28, Math.round(width * 0.12)));
          const c1x = a.x + (i % 2 === 0 ? hor : -hor * 0.6);
          const c2x = b.x + (i % 2 === 0 ? -hor * 0.6 : hor);
          const c1y = a.y + (b.y - a.y) * 0.35;
          const c2y = a.y + (b.y - a.y) * 0.65;
          d += ` C ${c1x},${c1y} ${c2x},${c2y} ${b.x},${b.y}`;
        }
        return d;
      };

      useEffect(() => {
        const updatePath = () => {
          if (!containerRef.current || !pathRef.current || !bgPathRef.current || !svgRef.current) return;
          
          const w = containerRef.current.clientWidth;
          const h = containerRef.current.scrollHeight;
          const d = generatePath(h, w);
          
          pathRef.current.setAttribute("d", d);
          bgPathRef.current.setAttribute("d", d);
          svgRef.current.setAttribute("viewBox", `0 0 ${Math.max(120, w)} ${h}`);
          svgRef.current.style.height = h + "px";
          
          const len = pathRef.current.getTotalLength();
          pathLenRef.current = len;
          pathRef.current.style.strokeDasharray = len;
          pathRef.current.style.strokeDashoffset = len;
          bgPathRef.current.style.strokeDasharray = len;
          bgPathRef.current.style.strokeDashoffset = 0;
        };

        // Small delay to ensure DOM is ready
        setTimeout(updatePath, 100);
        window.addEventListener("resize", updatePath);
        return () => window.removeEventListener("resize", updatePath);
      }, []);

      useEffect(() => {
        const onScroll = () => {
          if (!containerRef.current || !pathRef.current) return;
          
          const rect = containerRef.current.getBoundingClientRect();
          const top = window.scrollY + rect.top;
          const h = rect.height;
          const viewportBottom = window.scrollY + window.innerHeight;
          let progress = (viewportBottom - top) / h;
          progress = Math.min(Math.max(progress, 0), 1);
          const min = 0.06;
          const norm = min + progress * (1 - min);
          const len = pathLenRef.current;
          pathRef.current.style.strokeDashoffset = len * (1 - norm);
        };

        window.addEventListener("scroll", onScroll, { passive: true });
        onScroll();
        return () => window.removeEventListener("scroll", onScroll);
      }, []);

      useEffect(() => {
        if (!containerRef.current) return;

        const obs = new IntersectionObserver((entries) => {
          entries.forEach(e => {
            const i = Number(e.target.dataset.index);
            if (e.isIntersecting) {
              e.target.classList.add('visible');
              setActiveIndex(i);
            } else {
              e.target.classList.remove('visible');
            }
          });
        }, { threshold: 0.25 });

        const nodes = containerRef.current.querySelectorAll('.node');
        nodes.forEach(n => obs.observe(n));
        return () => obs.disconnect();
      }, []);

      return React.createElement('div', {
        ref: containerRef,
        style: {
          position: 'relative',
          padding: '40px',
          background: colors.bg,
          color: colors.accent
        }
      }, [
        React.createElement('style', { key: 'styles' }, `
          .timeline { position: relative; padding-left: 40px; }
          svg { position: absolute; left: 0; top: 0; width: 100%; pointer-events: none; }
          path { fill: none; stroke-linecap: round; }
          .bg { stroke: ${colors.accent}; opacity: 0.15; stroke-width: 6; }
          .progress { stroke: ${colors.accent}; stroke-width: 6; }
          .node { 
            margin: 110px 0; 
            opacity: 0; 
            transform: translateY(36px) scale(0.96);
            transition: all .7s cubic-bezier(.2,.9,.2,1);
          }
          .node.visible { 
            opacity: 1; 
            transform: translateY(0) scale(1); 
          }
          .dot { 
            position: absolute; 
            left: -10px; 
            width: 36px; 
            height: 36px; 
            border-radius: 50%;
            background: linear-gradient(135deg, ${colors.deep}, ${colors.accent});
            display: flex; 
            align-items: center; 
            justify-content: center; 
            color: ${colors.bg};
            font-weight: 700; 
            box-shadow: 0 6px 20px rgba(0,0,0,.6);
          }
          .card { 
            margin-left: 60px; 
            background: rgba(255,255,255,.03); 
            border: 1px solid rgba(255,255,255,.04);
            padding: 18px; 
            border-radius: 12px;
          }
          .message { 
            position: fixed; 
            right: 24px; 
            bottom: 24px; 
            min-width: 300px; 
            max-width: 480px;
            background: ${colors.accent}; 
            color: ${colors.bg}; 
            padding: 22px 26px; 
            border-radius: 14px;
            box-shadow: 0 18px 46px rgba(0,0,0,.75); 
            transform: translateY(20px);
            opacity: 0; 
            transition: all .42s ease; 
            font-size: 1.05rem;
          }
          .message.show { 
            opacity: 1; 
            transform: translateY(0); 
          }
        `),
        
        React.createElement('h2', { 
          key: 'title',
          style: { margin: 0, fontSize: 28 } 
        }, 'Roadmap'),
        
        React.createElement('p', { 
          key: 'subtitle',
          style: { color: '#ccc' } 
        }, 'Scroll to reveal each stage.'),

        React.createElement('div', { 
          key: 'timeline',
          className: 'timeline' 
        }, [
          React.createElement('svg', { 
            key: 'svg',
            ref: svgRef 
          }, [
            React.createElement('path', { 
              key: 'bg-path',
              ref: bgPathRef, 
              className: 'bg', 
              d: '' 
            }),
            React.createElement('path', { 
              key: 'progress-path',
              ref: pathRef, 
              className: 'progress', 
              d: '' 
            })
          ]),

          ...nodes.map((n, i) => 
            React.createElement('div', {
              key: i,
              className: 'node',
              'data-index': i
            }, [
              React.createElement('div', { 
                key: 'dot',
                className: 'dot' 
              }, i + 1),
              React.createElement('div', { 
                key: 'card',
                className: 'card' 
              }, [
                React.createElement('h3', { 
                  key: 'title',
                  style: { margin: '0 0 6px' } 
                }, n.title),
                React.createElement('p', { 
                  key: 'message',
                  style: { margin: 0, color: '#ddd' } 
                }, n.message)
              ])
            ])
          )
        ]),

        React.createElement('div', {
          key: 'message',
          className: `message ${activeIndex !== null ? 'show' : ''}`
        }, activeIndex !== null ? [
          React.createElement('div', { 
            key: 'title',
            style: { fontWeight: 700, marginBottom: 8 } 
          }, nodes[activeIndex].title),
          nodes[activeIndex].message
        ] : "Scroll to begin")
      ]);
    }

    // Wait for DOM to be ready
    document.addEventListener('DOMContentLoaded', function() {
      const root = ReactDOM.createRoot(document.getElementById("roadmap"));
      root.render(React.createElement(Roadmap));
    });
  </script>
</body>
</html>